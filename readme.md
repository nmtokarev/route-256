# Route 256 июнь 2022

## Задача B
В магазине акция: «купи три одинаковых товара и заплати только за два». Конечно, каждый купленный товар может участвовать лишь в одной акции. Акцию можно использовать многократно.\
Например, если будут куплены 7 товаров одного вида по цене 2 за штуку и 5 товаров другого вида по цене 3 за штуку, то вместо 7⋅2+5⋅3 надо будет оплатить 5⋅2+4⋅3=22.\
Считая, что одинаковые цены имеют только одинаковые товары, найдите сумму к оплате.\
**Входные данные**\
В первой строке записано целое число $t$ ($1 \leq t \leq 10^4$) — количество наборов входных данных.\
Далее записаны наборы входных данных. Каждый начинается строкой, которая содержит $n$ ($1 \leq n \leq 2 \cdot 10^4$) — количество купленных товаров. Следующая строка содержит их цены $p_1, p_2, ..., p_n$ ($1 \leq p_i \leq 10^4$). Если цены двух товаров одинаковые, то надо считать, что это один и тот товар.\
Гарантируется, что сумма значений $n$ по всем тестам не превосходит $2 \cdot 10^5$.\
**Выходные данные**\
Выведите $t$ целых чисел — суммы к оплате для каждого из наборов входных данных.\
**Пример входных данных**

    6
    12
    2 2 2 2 2 2 2 3 3 3 3 3
    12
    2 3 2 3 2 2 3 2 3 2 2 3
    1
    10000
    9
    1 2 3 1 2 3 1 2 3
    6
    10000 10000 10000 10000 10000 10000
    6
    300 100 200 300 200 300

**Пример выходных данных**

    22
    22
    10000
    12
    40000
    1100


## Задача C

Вам необходимо написать часть функциональности обработки сортировок в электронных таблицах.\
Задана прямоугольная таблица $n \times m$ ($n$ строк по $m$ столбцов) из целых чисел.\
Если кликнуть по заголовку $i$-го столбца, то строки таблицы пересортируются таким образом, что в этом столбце значения будут идти по неубыванию (то есть возрастанию или равенству). При этом, если у двух строк одинаковое значение в этом столбце, то относительный порядок строк не изменится.\
Рассмотрим пример.\
![](/images/taskC.png)
В этом примере сначала клик был совершен по второму столбцу, затем по первому и, наконец, по третьему.\
Заметим, что если кликнуть подряд два раза в один столбец, то после второго клика таблица не изменится (в момент второго клика она уже отсортирована по этому столбцу).\
Обработайте последовательность кликов и выведите состояние таблицы после всех кликов.\
**Входные данные**\
В первой строке записано целое число $t$ ($1 \leq t \leq 100$) — количество наборов входных данных в файле. Далее следуют описания наборов, перед каждым из них записана пустая строка.\
В первой строке набора записаны два целых числа $n$ и $m$ ($1 \leq n,m \leq 30$) — количество строк и столбцов в таблице.\
Далее следуют $n$ строк по $m$ целых чисел в каждой — начальное состояние таблицы. Все элементы таблицы от 1 до 100.\
Затем входные данные содержат строку с один целым числом $k$ ($1 \leq k \leq 30$) — количество кликов.\
Следующая строка содержит $k$ целых чисел $c_1,c_2,...,c_k$ ($1 \leq c_i \leq m$) — номера столбцов, по которым были осуществлены клики. Клики даны в порядке их совершения.\
**Выходные данные**\
Для каждого набора входных данных выведите $n$ строк по $m$ чисел в каждой — итоговое состояние таблицы. После каждого набора выходных данных выводите дополнительный перевод строки.\
**Пример входных данных**

    3

    4 3
    3 4 1
    2 2 5
    2 4 2
    2 2 1
    3
    2 1 3

    3 1
    100
    9
    10
    2
    1 1

    3 3
    2 11 72
    99 11 13
    2 8 13
    5
    2 3 2 1 2

**Пример выходных данных**

    2 2 1
    3 4 1
    2 4 2
    2 2 5

    9
    10
    100

    2 8 13
    2 11 72
    99 11 13

## Задача D

Реализуйте часть подсистемы валидации для функциональности регистрации.\
Задана последовательность строк — это логины, которые указывали пользователи при регистрации. Для каждого логина вывести YES или NO в зависимости от того валидный это логин или нет.\
Надо проверять, что логин — это последовательность из латинских букв в любом регистре, цифр и символов '_' или '-' (подчеркивание и дефис). Логин не должен начинаться с дефиса. Логин должен иметь длину от 2 до 24 символов. Логины, которые отличаются только регистром, считаются одинаковыми.\
Если логин задан многократно, то только первое его вхождение проходит валидацию (зарегистрироваться повторно с таким же логином нельзя). Например, если сперва происходит регистрация с логином tester, а затем с логином TesteR, то вторая попытка будет неуспешной (надо вывести NO для неё).\
**Входные данные**\
В первой строке задано целое число $t$ ($1 \leq t \leq 10^4$) — количество наборов входных данных в тесте.\
Вторая строка содержит целое число $n$ ($1 \leq n \leq 2⋅10^5$) — количество попыток регистрации в системе. Попытки заданы в хронологическом порядке (от самой ранней до самой поздней).\
Далее идёт $n$ строк, каждая содержит данные, которые указал пользователь в виде логина. Длина заданной строки может быть любой от 1 до 255 символов. В качестве символов могут быть любые символы с кодами от 33 (символ '!') до 126 (символ ' ') — такие символы не содержат национальные буквы различных языков и могут быть прочитаны как строка средствами стандартной библиотеки языка обычным способом.\
Сумма значений $n$ по всем наборам входных данных не превосходит $2⋅10^5$. Сумма длин логинов по всем наборам входных данных не превосходит $10^6$.\
**Выходные данные**\
Выведите ответы на $t$ наборов входных данных. Каждый ответ должен состоять из $n$ строк, которые содержат YES или NO.\
После каждого ответа на набор выходных данных выводите дополнительный перевод строки.\
Вы можете выводить YES и NO в любом регистре (например, строки yEs, yes, Yes и YES будут распознаны как положительный ответ).
**Пример входных данных**

    3
    10
    a
    _tester
    tester
    tester1
    ~~~!!!
    911
    -test-me
    test_me-93
    ?
    abcdefghijlmnopqkrstuvwxyz
    8
    1
    11
    111
    a
    aa
    aaa
    _
    __
    5
    one
    One
    onE
    ONE
    two
**Пример выходных данных**

    NO
    YES
    YES
    YES
    NO
    YES
    NO
    YES
    NO
    NO

    NO
    YES
    YES
    NO
    YES
    YES
    NO
    YES

    YES
    NO
    NO
    NO
    YES

## Задача E

Напишите программу, которая по заданному журналу звонков восстанавливает адресную книгу.\
Каждая запись журнала имеет вид: «имя_абонента телефон_абонента». Записи даны в хронологическом порядке от наиболее ранней к самой последней.\
Адресная книга позволяет хранить по имени абонента один или несколько его телефонов (но не более пяти). Если в журнале для абонента содержится более пяти телефонов, то сохранятся пять наиболее «свежих» (то есть таких, что последний звонок по ним был как можно позже). Иными словами, из телефонной книги выбрасываются те номера, по которым дольше всего не было звонка.\
Выведите телефонную книгу как набор строк в формате «имя_абонента: $n~t_1~t_2~...~t_n$», где $n$ от 1 до (включительно), а $t_1~t_2~...~t_n$ — номера абонента в порядке от наиболее недавно использованного. Строки в телефонной книге сортируйте в порядке лексикографического возрастания имён абонентов (то есть просто алфавитно).\
**Входные данные**
В первой строке записано целое число $t$ ($1 \leq t \leq 10^4$) — количество наборов входных данных.\
Далее записаны $t$ наборов входных данных.\
Описание каждого набора начинается строкой, содержащей целое число $n$ ($1 \leq n \leq 10^5$) — количество записей в журнале.\
Далее идут $n$ строк, каждая содержит одну запись журнала. Записи заданы в хронологическом порядке от наиболее старой к наиболее новой. Каждая запись имеет вид: «имя_абонента телефон_абонента», где имя_абонента — это строка длины от 1 до 8, которая состоит из строчных латинских букв, а телефон_абонента — это строка, которая содержит ровно 7 цифр (может начинаться с нуля). Гарантируется, что нет двух абонентов с одинаковым номером (то есть каждый номер соответствует одному абоненту).\
Гарантируется, что сумма значений $n$ по всем наборам входных данных в тесте не превосходит $10^5$.\
**Выходные данные**\
Для каждого набора входных данных выведите соответствующую телефонную книгу в виде последовательности строк «имя_абонента: $n~t_1~t_2~...~t_n$», где $n$ от 1 до 5 (включительно), а $t_1~t_2~...~t_n$ — номера абонента в порядке от наиболее недавно использованного. Строки в телефонной книге сортируйте в порядке лексикографического возрастания имён абонентов (то есть просто алфавитно).\
После каждой телефонной книги выводите дополнительный перевод строки.\
**Пример входных данных**

    5
    6
    ivan 1234567
    sergey 0000000
    ivan 1234567
    ivan 1234567
    sergey 0000001
    sergey 0000000
    10
    a 1000007
    a 1000003
    a 1000006
    a 1000009
    a 1000002
    a 1000004
    a 1000001
    a 1000006
    a 1000007
    a 1000004
    1
    abcdefgh 9876543
    4
    aa 0000001
    aaaa 0000003
    a 0000004
    aaa 0000002
    15
    a 0000001
    b 0000111
    a 0000008
    b 0000004
    b 0000003
    a 0000007
    a 0000011
    a 0000009
    b 0001111
    a 0000001
    b 0011111
    b 0000002
    b 0000004
    a 0000013
    b 0000002

**Пример выходных данных**

    ivan: 1 1234567
    sergey: 2 0000000 0000001

    a: 5 1000004 1000007 1000006 1000001 1000002

    abcdefgh: 1 9876543

    a: 1 0000004
    aa: 1 0000001
    aaa: 1 0000002
    aaaa: 1 0000003

    a: 5 0000013 0000001 0000009 0000011 0000007
    b: 5 0000002 0000004 0011111 0001111 0000003

## Задача F

Есть вагон, в котором $n$ купе, каждое купе содержит 2 места (купе типа СВ). Места пронумерованы от 1 до $2n$ подряд (места 1-2 — это первое купе, места 3-4 — второе и так далее). Надо обрабатывать три вида запросов:
- купить билет на заданное место (надо ответить SUCCESS или FAIL в зависимости свободно оно сейчас или нет) и пометить это место занятым;
- вернуть билет на заданное место (ответить SUCCESS или FAIL в зависимости удачно завершилась операция или нет) и разметить место, то есть SUCCESS надо выводить, если место было на данный момент занято;
- выкупить целиком купе (ответить либо FAIL, либо вывести SUCCESS X-Y — границу мест в первом полностью свободном купе), пометить все места этого купе занятыми.
Обработайте все запросы.

**Входные данные**\
В первой строке записано целое число $t$ ($1 \leq t \leq 10^4$) — количество наборов входных данных в тесте.\
Далее следуют описания $t$ наборов входных данных. Перед каждым описанием набора входных данных записана пустая строка.\
Описание каждого набора начинается строкой, в которой записаны два целых числа $n$ и $q$ ($1 \leq n \leq 3⋅10^5$, $1 \leq m \leq 6⋅10^5$) — количество купе в вагоне и количество запросов для обработки.\
Далее следуют сами запросы по одному в строке:
- запрос на покупку конкретного места записан как два числа: «1 $p$», где $p$ — целое число от 1 до $2n$ (номер места);
- запрос на сдачу билета по номеру места записан как два числа: «2 $p$», где $p$ — целое число от 1 до $2n$ (номер места);
- запрос на то, чтобы выкупить первое полностью свободное купе, записан как строка с одним целым числом 3.
  
Гарантируется, что сумма значений $n$ по всем наборам входных данных не превосходит $3⋅10^5$. Аналогично, гарантируется, что сумма значений $m$ по всем наборам входных данных не превосходит $6⋅10^5$.

**Выходные данные**\
Для каждого набора входных данных выведите ответы на него, по одному ответу на запрос в строке:

- для запроса 1-го типа: если место было свободно, то выведите SUCCESS, иначе выведите FAIL;
- для запроса 2-го типа: если место было занято, то выведите SUCCESS, иначе выведите FAIL;
- для запроса 3-го типа: если было хотя бы одно полностью пустое купе, то выведите SUCCESS X-Y (где X-Y — места первого свободного купе, которое нашла ваша программа), иначе выведите FAIL.
Выведите пустую строку после каждого ответа для набора входных данных.

**Пример входных данных**

    3

    16 11
    1 3
    1 3
    2 3
    3
    3
    2 1
    2 2
    2 3
    3
    2 4
    3

    1 7
    1 1
    3
    2 2
    3
    2 1
    3
    3

    100000 4
    3
    3
    3
    3

**Пример выходных данных**

    SUCCESS
    FAIL
    SUCCESS
    SUCCESS 1-2
    SUCCESS 3-4
    SUCCESS
    SUCCESS
    SUCCESS
    SUCCESS 1-2
    SUCCESS
    SUCCESS 3-4

    SUCCESS
    FAIL
    FAIL
    FAIL
    SUCCESS
    SUCCESS 1-2
    FAIL

    SUCCESS 1-2
    SUCCESS 3-4
    SUCCESS 5-6
    SUCCESS 7-8

